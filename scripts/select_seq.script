#!/bin/bash
#SBATCH --job-name=select_seq
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --time 6:00:00
#SBATCH -p QUEUE

# check if script is started via SLURM or bash
# if with SLURM: there variable '$SLURM_JOB_ID' will exist
# `if [ -n $SLURM_JOB_ID ]` checks if $SLURM_JOB_ID is not an empty string
if [ -n $SLURM_JOB_ID ];	then
	# check the original location through scontrol and $SLURM_JOB_ID
	SCRIPT_PATH=$(scontrol show job $SLURM_JOBID | awk -F= '/Command=/{print $2}' | cut -d' ' -f1)
else
	# otherwise: started with bash. Get the real location.
	SCRIPT_PATH=$(realpath $0)
fi

# getting location of software_name 
SHARED_PATH=$(dirname ${SCRIPT_PATH})

input_files=$(find . -name "*.seq_list")
FILE_COUNT=`ls $input_files | wc -l`
FILE_COUNT=$(( $FILE_COUNT - 1 ))

PARTS=50

if (( ${FILE_COUNT} < ${PARTS} )); then
	PARTS=${FILE_COUNT}
fi

# Loop over each file
for file in ${input_files}; do
	# Count the number of lines in the file
	num_lines=$(wc -l < $file)

	# Add the file name and number of lines to an array
	file_array+=("$num_lines $file")
done

# Sort the array by number of lines (in descending order)
IFS=$'\n' sorted_array=($(sort -nr <<<"${file_array[*]}"))

# Loop over each file in the sorted array
#for file in "${sorted_array[@]}"; do
#	# Get the file name (second element in array)
#	file_name=$(echo $file | cut -d' ' -f2)
#
#	# Do something with the file here...
#	echo ${file_name}
#done

ls *.seq_list > seq.list
split -n l/${PARTS} seq.list seq.list.part.
sbatch --array=1-${PARTS} -N1 --parsable --wait ${SHARED_PATH}/select_seq_job.script &
chmod +x ${SHARED_PATH}/select_seq_job.script
#${SHARED_PATH}/select_seq_job.script # For executing job 0
wait
